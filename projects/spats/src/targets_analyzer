#!/usr/bin/env python

#Written by Ray Zhuang 2013 to analysis input target fasta files for Spats
#Looks for 3' uniqueness (defines default for min_read_len), as well as 
#minimum required length of adapter to search for with clipper (defines trim-match by default)

import sys
import os
import getopt

from sys import stdout

present_dir = os.getcwd()+"/"

help_message = '''
targets_analyzer takes a targets file for alignment in spats and determines how many nucleotides
at the 3' end are required for unique alignment as well as to search for A_adapter_b similarity to set 
a proper trim-match value for adapter clipping.

Usage: 
    targets_analyzer <targets.fa>

Options:
-h,--help           brings up help
-v,--version        displays version number
'''

class Usage(Exception):
   def __init__(self,msg):
       self.msg = msg

def get_version():
    return "0.0.1"

class Params:
    def __init__(self):
       pass

    def parse_options(self, argv):
        
        try:
            opts, args = getopt.getopt(argv[1:],"hv",["help","version"])            

        except getopt.error, msg:
            raise Usage(msg)
 
        for option, arg in opts:
            if option in ("-v", "--version"):
                print "targets_analysis v%s" % (get_version())
                exit(0)
            if option in ("-h", "--help"):
                raise Usage(help_message)
                
        if len(args) != 1:
            raise Usage(help_message)
    
        return args
        
    def check(self):
        pass       

def reverse_complement(s):
    #This section was taken from Cole's code
    nuc_table = { 'A' : 'T',
                  'T' : 'A',
                  'C' : 'G',
                  'G' : 'C',
                  'a' : 't',
                  't' : 'a',
                  'c' : 'g',
                  'g' : 'c'  }
    sl = list(s)
    try:
        rsl = [nuc_table[x] for x in sl]
    except KeyError, k:
        print >> sys.stderr, "Error: adapter sequences must contain only A,C,G,T"
        exit(1)
    rsl.reverse()
    return ''.join(rsl)

def readFASTA(input_file):
 
    reader = open(input_file)
    thisFile = reader.readlines()    
    
    A_b_sequence = "AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAGACCGATCTCGTATGCCGTCTTCTGCTTG"
    minCount = 5

    #Define the number of uniqueness among the input RNA sequences, the max number such that all are unique
    uniqueNuc = 0

    #Create a local array to hold everything
    tempArray = []

    #Create array that will contain all unique sequences seen so far
    uniqArray = []

    #Here, we just get the smaller set of sequences, without the titles
    for arrayEl in thisFile:
        realEl = arrayEl.strip() #last array element is the newline, so we'll skip it. Python's :blah will not include the blah index
        #KEW ^replaced with strip to remove any trailing newlines, etc.(in cases spaces, etc. are left too)
        if (arrayEl != "\n") & (arrayEl[0] != ">"):
            tempArray.append(realEl)
            #print realEl[(len(realEl)-1):] #This is the last nucleotide
    
    seqArray = tempArray
    shortest = False
    
    #print tempArray
    while (len(uniqArray) != len(tempArray)):
        for el in tempArray:
            if (not uniqArray.__contains__(el[(len(el)-1-uniqueNuc):])): #If we haven't seen it, then append it
                uniqArray.append(el[(len(el)-1-uniqueNuc):])
        #print uniqArray
        if (len(uniqArray) != len(tempArray)):
            uniqArray = []
            uniqueNuc = uniqueNuc + 1
    
    #Reverse complement of the file, and then add AGAT at the front (to mimic it coming up randomly in the handle sequence
    for el in range(0,len(seqArray)):
        seqArray[el] = "AGAT" + reverse_complement(seqArray[el])
    
    while ((shortest == False) & (minCount < 35)):
        uniqArray = [] #KEW - needed to flush string to 'reset' length search with each loop
        A_b_match = A_b_sequence[0:minCount]  #Number that we're trying to match
        #Now check if we already have that sequence
        for seq in seqArray:
            for char in range(0,len(seq)-minCount+1):
                if ((seq[char:(char+minCount)] == A_b_match)):
                    uniqArray.append(seq)
        #print(uniqArray)
        if(len(uniqArray) != 0): #Should be empty when A_b cannot be found at the given length
            shortest = False
            minCount += 1
        else:
            shortest = True

    return uniqueNuc, minCount

def main(argv=None):

    params = Params()
    
    try:
        if argv is None:
            argv = sys.argv
            args = params.parse_options(argv)
            params.check()     

        inputfile = args[0]
   
        #stdout.write("\rRunning the Parser for Script........")
        #stdout.flush()       
        
	#Get number of nucleotides to search for adapter	
	unique_num,A_b_search_len = readFASTA(inputfile)
        #print("done\n")
        print("Number of nucleotides from 3' end needed to be unique: " + str(unique_num))     
        print("AGAT search length is: " + str(A_b_search_len))              

    except Usage, err:
        print >> sys.stderr, sys.argv[0].split("/")[-1] + ": " + str(err.msg)
        print >> sys.stderr, ""
        return 2     

if __name__ == "__main__":
    sys.exit(main())

