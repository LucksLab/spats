#!/usr/bin/env python

import targets_analyzer
import sys
import os
import getopt
import shutil
from datetime import datetime, date, time
#import targets_analyzer #looks at targets file and determines similarity at 3' end


current_dir = os.getcwd()+'/'

help_message = '''
Adapter_trim takes fastq files, searches for short sequences that are reverse complimentary,
trims off adapter sequences, and prepares reads for processing directly with spats
   
Usage: 
   Adapter_trim [options] <R1_seq.fastq> <R2_seq.fastq> <targets.fa>

Options:    
-h, --help                  opens help message
-v, --version               displays version number     
--trim-match <N>            number of nucleotides of adapter to search for with clipper (default = 6) *Adjust trim length this way
--read-length <N>           Number of length of reads (ex. 35 for 2x35 bp paired end reads) (default = 35)
--min-read-len <n>          Number of nt on the 3' end to leave after (w/ adapter) (default = 6)
--A-b-sequence <string>     A_adapter_b sequence (default: AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAGACCGATCTCGTATGCCGTCTTCTGCTTG)
--A-t-sequence <string>     A_adapter_t sequence (default: AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT)
--max-handle-len <N>        Number of nucleotides in the longest (+/-) handle (default = 4 for RRRY/YYYR)
-o, --output <string>       If running many simultaneously runs in the same folder, use this option to name the treated reads
                            folder to avoid overwriting during processing
'''

def get_version():
    return "0.0.2"

class Usage(Exception):
    def __init__(self,msg):
        self.msg = msg

class Params:
    
    def __init__(self):
        pass
    
    def parse_options(self, argv):
        try:
            opts, args = getopt.getopt(argv[1:], "hvo:",
                                       ["version",
                                        "help",
                                        "trim-match=",
                                        "read-len=",
                                        "A-b-sequence=",
                                        "A-t-sequence=",
                                        "min-read-len=",
                                        "output=",
                                        "max-handle-len="])
                                        
        except getopt.error, msg:
            raise Usage(msg)
       
        trim_match = 6
        trim_auto = True
        read_len = 35
        A_b_sequence = "AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAGACCGATCTCGTATGCCGTCTTCTGCTTG"
        A_t_sequence = "AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT" 
        final_dir = current_dir + "combined_reads_tmp/"
        max_handle_len = 4
        min_read_auto = True
        min_read_len = 6
        for option, value in opts:
            if option in ("-v", "--version"):
                print "Adapter_trimmer v%s" % (get_version())
                exit(0)
            if option in ("-h", "--help"):
                raise Usage(help_message)
            if option in ("--trim-match"):
                trim_auto = False
                trim_match = int(value)
            if option in ("--read-len"):
                read_len = int(value)
            if option in ("--A-b-sequence"):
                A_b_sequence = value
            if option in ("--A-t-sequence"):
                A_t_sequence = value
            if option in ("--min-read-len"):
                min_read_len = int(value)
                min_read_auto = False
            if option in ("-o","--output"):
                final_dir = value
            if option in ("--max-handle-len"):
                max_handle_len = int(value)
        
        A_t_sequence = reverse_complement(A_t_sequence)
                                    
        if len(args) != 3:
            raise Usage(help_message)
        return args,trim_match,read_len,A_b_sequence,A_t_sequence,min_read_len,final_dir,trim_auto,min_read_auto,max_handle_len

    def check(self):
        pass

def trim_min_read_calculator(trim_auto,min_len_auto,input_targets,max_handle_len,trim_match,min_read_len,read_len):
    
    #Call Ray's script to find the minimal lengths of A_b to search and number of nucleotides to trim from 3' end
    uniqueness,A_b_search_len = targets_analyzer.readFASTA(input_targets)
    
    if min_len_auto == True:
        min_read_len = max_handle_len + uniqueness
        print >> sys.stderr, "[%s] Automatically dropping %s nt from end of RNAs (from 3' end analysis)" % (right_now(),uniqueness)
    else:
        print >> sys.stderr, "[%s] Manually dropping %s nt from end of reads" % (right_now(),min_read_len)
    
    if trim_auto == True:
        if A_b_search_len >= read_len:
            trim_match = read_len - min_read_len  #
        else:
            trim_match = A_b_search_len + 1  #Adds two greater than the longest A_b sequence found
        print >> sys.stderr, "[%s] Automatically set trim-match to %s based on targets file" % (right_now(),trim_match)
    else:
         print >> sys.stderr, "[%s] Trim-match manually set to %s" % (right_now(),trim_match)
    
    return trim_match,min_read_len
    
def right_now():
    curr_time = datetime.now()
    return curr_time.strftime("%c")

def quality_mod(inputfile):
    #Modifies all of the quality reads to 'I' so that fastx ignores qualities
    qualmodfile = inputfile[:-6] + '_Qs.fastq'
    qualcommand = "awk \'BEGIN{s=0} {s += 1; if (s % 4 == 0) print \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\"; else print }\'"
    #this is needed to except the curly brackets in the below command
    os.system(qualcommand +" {0} > {1}".format(inputfile, qualmodfile));
    #print("done")
    return qualmodfile

def formatTD(td):
    hours = td.seconds // 3600
    minutes = (td.seconds % 3600) // 60
    seconds = td.seconds % 60
    return '%02d:%02d:%02d' % (hours, minutes, seconds)    
            
def reverse_complement(s):
    #This section was taken from Cole's code
    nuc_table = { 'A' : 'T',
                  'T' : 'A',
                  'C' : 'G',
                  'G' : 'C',
                  'a' : 't',
                  't' : 'a',
                  'c' : 'g',
                  'g' : 'c'  }
    sl = list(s)
    try:
        rsl = [nuc_table[x] for x in sl]
    except KeyError, k:
        print >> sys.stderr, "Error: adapter sequences must contain only A,C,G,T"
        exit(1)
    rsl.reverse()
    return ''.join(rsl)
 
def relabel_reads(params, input_R1, input_R2, treated_handle, untreated_handle, current_dir,relabel=True):    
    #filter_cmd = ["prep_reads"]
    print >> sys.stderr, "[%s] Relabeling reads in %s and %s" % (right_now(), input_R1, input_R2)
    
    #filter_log = open(logging_dir + "relabel_reads.log", "w")
    
    filter_cmd = "relabel_reads --output-dir {0} --phred33-quals --fastq {1} {2}".format(current_dir,input_R1,input_R2)
    os.system(filter_cmd)
    
    #print "\t executing: `%s'" % " ".join(filter_cmd)    
     
def match_read_pairs(params, left_in_reads, right_in_reads, left_out_reads, right_out_reads):
    
    #filter_cmd = ["prep_reads"]
    print >> sys.stderr, "[%s] Rematching read pairs" % (right_now())

    #filter_log = open(logging_dir + "relabel_reads.log", "w")
    
    cmd = ["match_read_pairs"]
    cmd.extend([left_in_reads, 
                right_in_reads, 
                left_out_reads, 
                right_out_reads])
       
    #print "\t executing: `%s'" % " ".join(cmd)    
    ret = os.system(" ".join(cmd))    
     
    return [left_out_reads, right_out_reads]          
                
def main(argv=None,):

    params = Params()
    
    search_dir = current_dir + "search_tmp/"
    output_dir = current_dir + "At_output_tmp/"
    targets_dir = current_dir + 'targets_tmp/'
       
    try:
        os.mkdir(output_dir)
    except:
        pass
          
    try:
        if argv is None:
            argv = sys.argv
            args,trim_match,read_len,A_b_sequence,A_t_sequence,min_read_len,final_dir,trim_auto,min_read_auto,max_handle_len = params.parse_options(argv)
            params.check()
    
        input_R1 = args[0]
        input_R2 = args[1]
        input_targets = args[2]
        
        print >> sys.stderr
        print >> sys.stderr, "[%s] Beginning Adapter_trimmer reads processing (v%s)" % (right_now(), get_version())
        print >> sys.stderr, "-----------------------------------------------------" 
        start_time = datetime.now()
        
        #Build bowtie targets for checking rev-comp pairs
        print >> sys.stderr, "[%s] Building Bowtie targets" % (right_now())
        try:
            os.mkdir(targets_dir)
        except:
            pass
        os.system("bowtie-build -q {0} {1}targets".format(input_targets,targets_dir))
        
        #If not manually input, decide what length is optimal for adapter clipping (shorter lengths save time/space)
        #Also if the minimum length to leave at the three prime end was undetermined
        trim_match,min_read_len = trim_min_read_calculator(trim_auto,min_read_auto,input_targets,max_handle_len,trim_match,min_read_len,read_len)
        trim_len = read_len-trim_match  
        
        #Modify all of of the quality scores to 'I' so that the fastx tools don't get hung up
        print >> sys.stderr, "[%s] Adjusting quality scores" % (right_now())
        input_R1 = quality_mod(input_R1)
        input_R2 = quality_mod(input_R2)
    
        #Define a list of files for R1 and R2 to store all of subsets of adapter matching (could clean up this section)
        filenames_R1 = []
        filenames_R2 = []
    
        #Now do a stepwise trim to search for rev comp in the window the clipper misses
        for base in range((read_len),trim_len,-1):
            print >> sys.stderr, "[%s] Finding reads that are %s nt long" % (right_now(), (base-max_handle_len))
            
            #Make a temporary folder for intermediate files to delete after each trim
            try:
                os.mkdir(search_dir)
            except:
                pass
     
            #Block of filename constructions for outputfiles
            output_R1 = search_dir + input_R1[:-6] + "_" + str(base) + ".fastq"
            output_R2 = search_dir + input_R2[:-6] + "_" + str(base) + ".fastq"
            output_revcomp_R1 = search_dir + input_R1[:-6] + "_" + str(base) + "_revcomp" + ".fastq"
            output_bowtie = search_dir + "bowtie_output_" + str(base) + ".sam"
            bowtie_results = output_dir + "bowtie_results{0}.fq".format(base)
            bowtie_results_rc = output_dir + "bowtie_results{0}_1_rc.fq".format(base)
            
            #Loop one base at a time to look for reverse complements to see if matching (use targets file as reference)
            os.system("fastx_trimmer -l {0} -i {1} -o {2}".format(base,input_R1,output_R1)) #search sequences that have been searched for clips
            os.system("fastx_trimmer -l {0} -i {1} -o {2}".format(base,input_R2,output_R2))
            os.system("fastx_reverse_complement -i {0} -o {1}".format(output_R1,output_revcomp_R1))
            os.system("bowtie -q --quiet --sam -p 1 -v 0 --ff --norc -3 4 -X 2000 -m 1 --al {4} --sam --allow-contain {0} -1 {1} -2 {2} {3}".format(targets_dir + "targets",output_revcomp_R1,output_R2,output_bowtie,bowtie_results))
            
            #Have to switch rev-comp of R1 back to original
            os.system("fastx_reverse_complement -i {0} -o {1}".format((bowtie_results[:-3]+"_1.fq"),bowtie_results_rc))
        
            #Add the aligned rev-comp files to the list of files to be recombined (Note: the original untrimmed window reads will also exist, but shouldn't align)
            filenames_R1.append(bowtie_results_rc)
            filenames_R2.append(output_dir + "bowtie_results{0}_2.fq".format(base))
            
            #Delete temporary files
            shutil.rmtree(search_dir,ignore_errors=True)
         
        #Relabel before clipping so mate pairs are not lost (use match_read)
        relabel_reads(params,input_R1,input_R2,None,None,current_dir)
    
        os.remove(input_R1)
        os.remove(input_R2)
        input_R1 = "NOMASK_1.fq"
        input_R2 = "NOMASK_2.fq"
    
        #Clip off adapter from the raw reads    
        output_R1_clipped = output_dir + input_R1[:-3] + "_clipped.fastq"
        output_R2_clipped = output_dir + input_R2[:-3] + "_clipped.fastq"
        
        os.system("fastx_clipper -M {3} -a {0} -l {4} -n -i {1} -o {2}".format(A_b_sequence[:trim_match],input_R1,output_R1_clipped,trim_match,min_read_len))
        #print("fastx_clipper -M {3} -a {0} -l {4} -n -i {1} -o {2}".format(A_b_sequence[:trim_match],input_R1,output_R1_clipped,trim_match,min_read_len))
        os.system("fastx_clipper -M {3} -a {0} -l {4} -n -i {1} -o {2}".format(A_t_sequence[:trim_match],input_R2,output_R2_clipped,trim_match,min_read_len))                                                                                                  
        #print("fastx_clipper -M {3} -a {0} -l {4} -n -i {1} -o {2}".format(A_t_sequence[:trim_match],input_R2,output_R2_clipped,trim_match,min_read_len))   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
        #trims leftover non-adapter sequences down in R1 and R2 to remove Ns problem from full length
        print >> sys.stderr, "[%s] Trimming down longer sequences to remove potential Ns at 3' end" % (right_now())
        output_R1_trimmed = output_dir + input_R1[:-3] + "_" + str(trim_len) + ".fastq"
        output_R2_trimmed = output_dir + input_R2[:-3] + "_" + str(trim_len) + ".fastq"
        os.system("fastx_trimmer -l {0} -i {1} -o {2}".format(trim_len,output_R1_clipped,output_R1_trimmed))
        os.system("fastx_trimmer -l {0} -i {1} -o {2}".format(trim_len,output_R2_clipped,output_R2_trimmed))
        
        #rematch read pairs immediately
        matched_R1 = output_dir + input_R1[:-3] + "_kept.fq"
        matched_R2 = output_dir + input_R2[:-3] + "_kept.fq"
        matched_reads = match_read_pairs(params, output_R1_trimmed, output_R2_trimmed, matched_R1, matched_R2)
        
        #Check trimmed sequences for rev-comp (to avoid doubling counts of sequences that were found by sequential trimming; keep those that aren't rev-comp)
        #In essence, this rejects any stops that are less than the read_len, leaving only reads that are 36 nt or longer (for 2x35 bp reads)
        #print("bowtie -q --quiet --sam -p 1 -n 0 -l {0} -5 4 -X {1} -m 1 --un not_aligned.fq --sam --allow-contain {2} -1 {3} -2 {4} {5}".format(trim_len,read_len,targets_dir + "targets",matched_reads[0],matched_reads[1],"trimmed_alignment.sam"))
        os.system("bowtie -q --quiet --sam -p 1 -n 0 -l {0} -5 4 -X {1} -m 1 --un not_aligned.fq --sam --allow-contain {2} -1 {3} -2 {4} {5}".format(trim_len,read_len,targets_dir + "targets",matched_reads[0],matched_reads[1],"trimmed_alignment.sam"))
        
        filenames_R1.append("not_aligned_1.fq")
        filenames_R2.append("not_aligned_2.fq")
        #print(filenames_R1)
        
        #Combine the found rev-comp pairs with the trimmed 
        print >> sys.stderr, "[%s] Combining all processed reads" % (right_now())
        try:
            os.mkdir(final_dir)
        except:
            pass
        
        combined_R1 = final_dir + 'combined_R1.fastq'
        combined_R2 = final_dir + 'combined_R2.fastq'
        
        if os.path.exists(combined_R1):
            os.remove(combined_R1)
        if os.path.exists(combined_R2):
            os.remove(combined_R2)
            
        with open(combined_R1, 'w') as outfile:
            for fname in filenames_R1:
                with open(fname) as infile:
                    for line in infile:
                        outfile.write(line)
                infile.close()
        outfile.close()
                        
        with open(combined_R2, 'w') as outfile:
            for fname in filenames_R2:
                with open(fname) as infile:
                    for line in infile:
                        outfile.write(line)
                    infile.close()
        outfile.close()    
    
        #Delete the rest of the temporary files
        shutil.rmtree(output_dir,ignore_errors=True)
        shutil.rmtree(targets_dir,ignore_errors=True)
        os.remove(input_R1)
        os.remove(input_R2)
        os.remove("trimmed_alignment.sam")
        for x in range(1,3):
           os.remove("not_aligned_{0}.fq".format(x))
        
        finish_time = datetime.now()
        duration = finish_time - start_time
        print >> sys.stderr,"-----------------------------------------------"
        print >> sys.stderr, "Run complete [%s elapsed]" % formatTD(duration)
        print >> sys.stderr   
                    
    except Usage, err:
        print >> sys.stderr, sys.argv[0].split("/")[-1] + ": " + str(err.msg)
        print >> sys.stderr, ""
        return 2       
    
if __name__ == "__main__":
    sys.exit(main())
